from __future__ import annotations

import attrs
import numpy as np
from scipy import stats

from pyloki.core import common
from pyloki.detection.scoring import boxcar_snr_1d
from pyloki.io.timeseries import TimeSeries
from pyloki.simulation import modulate


@attrs.define(auto_attribs=True, kw_only=True)
class PulseSignalConfig:
    """A pulsar signal generator configuration.

    Parameters
    ----------
    period : float
        Period of the pulsar.
    dt : float
        Time resolution of the generated time series
    nsamps : int, optional
        Number of samples in the generated time series, by default 2**21
    snr : float, optional
        Signal to noise ratio of the folded pulse profile, by default 100
    ducy : float, optional
        Duty cycle of the pulse (FWTM) in fractional phase, by default 0.1
        For slow pulsars, ducy ~ 0.03, for millisecond pulsars, ducy ~ 0.1 - 0.3
    ds : int, optional
        Down sampling factor for the folded phase bins, by default 1
    mod_type : str, optional
        Type of modulation, by default "derivative"
    mod_kwargs : dict, optional
        Modulation function parameters, by default None
    """

    period: float
    dt: float
    nsamps: int = 2**21
    snr: float = 100
    ducy: float = 0.1
    ds: float = 1.0
    mod_type: str = "derivative"
    mod_kwargs: dict[str, float] = attrs.Factory(dict)
    _mod_func: modulate.DerivativeModulating = attrs.field(init=False, repr=False)

    def __attrs_post_init__(self) -> None:
        self._mod_func = modulate.type_to_mods[self.mod_type](**self.mod_kwargs)
        self._check()

    @property
    def freq(self) -> float:
        """Pulsar frequency."""
        return 1 / self.period

    @property
    def tobs(self) -> float:
        """Total observation time."""
        return self.nsamps * self.dt

    @property
    def tol_bins(self) -> float:
        """Pulsar pulse width in bins."""
        return self.ducy * self.period / self.dt

    @property
    def fold_bins(self) -> int:
        """Number of phase bins in the folded profile."""
        return int(self.period / self.dt / self.ds)

    @property
    def fold_bins_ideal(self) -> int:
        """Number of ideal phase bins in the folded profile."""
        return int(self.period / self.dt)

    @property
    def mod_func(self) -> modulate.DerivativeModulating:
        """Modulation function."""
        return self._mod_func

    @property
    def proper_time(self) -> np.ndarray:
        """Proper time array."""
        return self.mod_func.generate(np.arange(0, self.tobs, self.dt), self.tobs / 2)

    def get_updated(self, update_dict: dict) -> PulseSignalConfig:
        new = attrs.asdict(self, filter=attrs.filters.exclude("_mod_func"))
        if update_dict is not None:
            new.update(update_dict)
        new_checked = {
            key: value for key, value in new.items() if key in attrs.asdict(self)
        }
        return PulseSignalConfig(**new_checked)

    def generate_old(
        self,
        shape: str = "gaussian",
        phi0: float = 0.5,
    ) -> TimeSeries:
        pulse = PulseShape(
            self.proper_time,
            self.dt,
            self.period,
            shape=shape,
            width=self.ducy,
            pos=phi0,
        )
        signal = pulse.generate()
        pulse_width = self.ducy * self.period / self.dt
        stdnoise = np.sqrt(self.nsamps * self.ducy) / self.snr / pulse_width
        rng = np.random.default_rng()
        signal += rng.normal(0, stdnoise, self.nsamps)
        signal_v = np.ones(self.nsamps) * stdnoise**2
        return TimeSeries(signal, signal_v, self.dt)

    def generate_noise(self) -> TimeSeries:
        """Generate a noise signal based on the configuration parameters."""
        stdnoise = np.sqrt(self.nsamps * self.ducy) / self.snr / self.tol_bins
        rng = np.random.default_rng()
        signal = rng.normal(0, stdnoise, self.nsamps)
        signal_v = np.ones(self.nsamps) * stdnoise**2
        return TimeSeries(signal, signal_v, self.dt)

    def generate(
        self,
        shape: str = "gaussian",
        phi0: float = 0.5,
        max_iter: int = 5,
        tol: float = 1e-2,
    ) -> TimeSeries:
        """Generate a periodic timeseries with a given shape and phase.

        The signal is generated by iteratively adjusting the amplitude of the signal
        to match the desired SNR.

        Parameters
        ----------
        shape : str, optional
            Shape of the pulse, by default "gaussian"
        phi0 : float, optional
            Phase of the pulse, by default 0.5
        max_iter : int, optional
            Maximum number of iterations, by default 5
        tol : float, optional
             Stop iterating if |measured_snr - snr_target| < tol, by default 1e-2

        Returns
        -------
        TimeSeries
            A simulated timeseries with the desired SNR.
        """
        rng = np.random.default_rng()
        pulse = PulseShape(
            self.proper_time,
            self.dt,
            self.period,
            shape=shape,
            width=self.ducy,
            pos=phi0,
        )
        sig_template = pulse.generate().astype(np.float32)
        noise_ts_unit = rng.normal(loc=0, scale=1, size=self.nsamps).astype(np.float32)

        # Integrate off-pulse noise
        nbins = self.fold_bins_ideal
        center_bin = round(phi0 * nbins) % nbins
        width_bins = max(1, round(self.ducy * nbins))
        on_pulse_indices = center_bin - (width_bins // 2) + np.arange(width_bins)
        on_pulse_indices = on_pulse_indices % nbins
        off_pulse_mask = np.ones(nbins, dtype=bool)
        off_pulse_mask[on_pulse_indices] = False
        noise_folded_unit = common.brutefold_single(
            noise_ts_unit,
            self.proper_time,
            1 / self.period,
            1,
            nbins,
        ).squeeze()
        noise_scale = 1.0 / np.std(noise_folded_unit[off_pulse_mask])
        sig_variance = np.full(self.nsamps, noise_scale**2, dtype=np.float32)

        # Get first guess for signal scale
        snr_template = self._calibrate_snr(sig_template, sig_variance)
        signal_scale = self.snr / snr_template

        # Iterative Refinement Loop (Additive Correction)
        scaled_noise_ts = noise_scale * noise_ts_unit  # Noise component is fixed
        current_signal_scale = signal_scale
        damping_factor = 0.8
        for _ in range(max_iter + 1):
            final_signal = scaled_noise_ts + current_signal_scale * sig_template
            measured_snr = self._calibrate_snr(final_signal, sig_variance)
            snr_diff = measured_snr - self.snr
            if abs(snr_diff) < tol:
                break
            # Additive correction: scale_new = scale_old - diff / sensitivity
            current_signal_scale += damping_factor * (-snr_diff / snr_template)
        return TimeSeries(final_signal, sig_variance, self.dt)

    def _calibrate_snr(
        self,
        sig_template: np.ndarray,
        sig_variance: np.ndarray,
    ) -> float:
        folds = common.brutefold(
            sig_template,
            sig_variance,
            self.proper_time,
            1 / self.period,
            1,
            self.fold_bins_ideal,
        ).squeeze()
        fold_norm = folds[0] / np.sqrt(folds[1])
        match_boxcar = boxcar_snr_1d(
            fold_norm,
            np.arange(1, self.fold_bins_ideal // 2),
            1.0,
        )
        return np.max(match_boxcar)

    def _check(self) -> None:
        if self.ducy <= 0 or self.ducy >= 1:
            msg = f"Duty cycle ({self.ducy}) should be in (0, 1)"
            raise ValueError(msg)


class PulseShape:
    """Generate a pulse shape.

    Parameters
    ----------
    proper_time : np.ndarray
        Proper time array.
    dt : float
        Time resolution.
    period : float
        Period of the pulsar.
    shape : str, optional
        Shape of the pulse, by default "gaussian"
    width : float, optional
        Duty cycle of the pulse (FWTM) in phase units, by default 0.1
    pos : float, optional
        Phase of the pulse peak, by default 0.5
    """

    def __init__(
        self,
        proper_time: np.ndarray,
        dt: float,
        period: float,
        shape: str = "gaussian",
        width: float = 0.1,
        pos: float = 0.5,
    ) -> None:
        self.proper_time = proper_time
        self.dt = dt
        self.period = period
        self.shape = shape
        self.width = width
        self.pos = pos

        self._rv = self._set_rv()

    @property
    def rv(self) -> stats.rv_continuous:
        return self._rv

    def generate(self) -> np.ndarray:
        phase_start = (self.proper_time % self.period) / self.period
        phase_end = ((self.proper_time + self.dt) % self.period) / self.period
        return np.where(
            phase_end > phase_start,
            self.rv.cdf(phase_end) - self.rv.cdf(phase_start),
            0,
        )

    def _set_rv(self) -> stats.rv_continuous:
        if self.shape == "boxcar":
            rv = stats.uniform(loc=self.pos, scale=self.width)
        elif self.shape == "gaussian":
            width = self.width / (2 * np.sqrt(2 * np.log(10)))
            rv = stats.norm(loc=self.pos, scale=width)
        elif self.shape == "von_mises":
            kappa = np.log(2.0) / (2.0 * np.sin(np.pi * self.width / 2.0) ** 2)
            rv = stats.vonmises(loc=self.pos, kappa=kappa)
        else:
            msg = f"Unknown pulse shape: {self.shape}"
            raise ValueError(msg)
        return rv


def von_mises_pulse_shape(
    proper_time: np.ndarray,
    dt: float,  # noqa: ARG001
    period: float,
    width: float,
    pos: float = 0.5,
) -> np.ndarray:
    kappa = np.log(2.0) / (2.0 * np.sin(np.pi * width / 2.0) ** 2)
    phase_radians = (proper_time / period - pos) * (2 * np.pi)
    return np.exp(kappa * (np.cos(phase_radians) - 1.0))


def generate_folded_profile(
    nbins: int = 100,
    ducy: float = 0.1,
    center: float = 0.5,
) -> np.ndarray:
    """Generate a normalized folded pulse profile."""
    phase = np.linspace(0, 1, nbins, endpoint=False)
    sigma = ducy / (2 * np.sqrt(2 * np.log(10)))
    wrapped_phase = np.mod(phase - center + 0.5, 1) - 0.5
    profile = np.exp(-(wrapped_phase**2) / (2 * sigma**2))
    profile = profile / profile.max()
    return profile / np.sqrt(np.sum(profile**2))
